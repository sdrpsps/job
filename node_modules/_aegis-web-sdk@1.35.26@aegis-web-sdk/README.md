# aegis-web-sdk


Aegis（读音/ˈiːdʒɪs/） 是腾讯云监控团队提供的前端监控 SDK，涵盖了错误监控，资源测速（img, script, css），接口测速，页面性能（首屏时间）。无需侵入代码，只需引入 SDK 即可自动完成所有监控上报。

在使用 aegis 时无需在业务代码中打点或者做任何其他操作，可以做到与业务代码充分解耦。aegis 将会自动监控前端错误，在错误发生时上报错误的具体情况，帮助您快速定位问题。当您开启资源测速时，aegis 将会自动监听页面资源加载情况（耗费时长、成功率等），并在不影响前端性能的前提下收集前端的性能数据，帮助您快速定位性能短板，提升用户体验。

使用本 SDK 需要配合使用腾讯云前端性能监控 [RUM 平台](https://console.cloud.tencent.com/rum)。

## Usage

1. 前往腾讯云前端性能监控 [RUM 平台](https://console.cloud.tencent.com/rum)

2. 申请项目，申请完成后得到`上报 id`，id 在 sdk 初始化的时候会使用。

Aegis SDK 在上报所有数据时都会带上`上报 id`，后端服务将根据`上报 id`辨别数据来自哪一个项目，因此，Aegis 建议为每一个项目都单独申请一个 id，如果一个项目下有多个页面，还可以为每一个页面都申请一个项目 id，方便单独查看每一个页面的 PV、错误率、请求错误率等数据。

## 使用SDK

### 安装 SDK

针对各种情况， SDK 提供了三种引入方式，选择适合业务中的一种即可。无论哪种使用方法，请务必保证 sdk 在 `<head></head>` 内，最先声明。这样能保证拿到各类数据监控。

1. cdn 引入

资源地址如下：

最新版本：https://cdn-go.cn/aegis/aegis-sdk/latest/aegis.min.js

特定版本(注意链接中的版本号)：https://cdn-go.cn/aegis/aegis-sdk/{version}/aegis.min.js

> 版本说明：为了保证CDN的稳定性，“latest” 版本将会比“npm”版本稍滞后一些；

将会在 window 上挂载 `Aegis` 构造函数。

2. npm 引入

```sh
$ npm install aegis-web-sdk
```

2. 内联引入

如果想要把 SDK 代码直接内联到 html 中的话，可以选择直接 copy 代码的方式，或者使用您熟悉打包工具的内联代码的工具

### SDK 实例化

引入 SDK 后，需实例化:

```javascript
const aegis = new Aegis({
  id: 'pGUVFTCZyewxxxxx',
  uin: 'xxx', // 用户唯一标识（可选）
  reportApiSpeed: true, // 接口测速
  reportAssetSpeed: true // 静态资源测速
});
```

::: warning 注意 ⚠️
为了不遗漏数据，须尽早进行初始化；
:::

::: tip 当您做了以上接入工作之后，您已经开始享受 Aegis 提供的以下功能：
1、错误监控：JS执行错误、Promise错误、Ajax请求异常、资源加载失败、返回码异常、pv上报、白名单检测等；  
2、测速：页面性能测速、接口测速、静态资源测速；  
3、数据统计和分析：可在 [RUM 平台](https://console.cloud.tencent.com/rum) 上查看各个维度的数据分析；  
:::

## 日志上报

创建完 Aegis 实例之后，就可以开心的上报日志啦 🥰，日志上报同样简单

```javascript
aegis.info(
  `我是一条白名单上报的信息，只有在白名单中的用户才会上报哟。`
);

aegis.infoAll(
  `我是一条普通的信息，每个用户调用后都可以上报，如果上报量很大的话请谨慎使用哟。`
);

aegis.error(
  new Error('我是一条主动上报的JS执行错误，你可以捕获错误后主动上报')
);
```

### aid

Aegis SDK 为每个用户设备分配的唯一标识，会存储在浏览器的 localStorage 里面，用来区分用户，计算 uv 等。aid 只有用户清理浏览器缓存才会更新。

算法如下:

```javascript
async getAid(callback: Function) {
// 某些情况下操作 localStorage 会报错.
  try {
    let aid = await localStorage.getItem('AEGIS_ID');
    if (!aid) {
    aid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
    localStorage.setItem('AEGIS_ID', aid);
    }
    callback?.(aid || '');
  } catch (e) {
    callback?.('');
  }
}
```

对于一些项目，使用自己构造的 aid 作为上报规则，后端对 aid 的校验规则如下：`/^[@=.0-9a-zA-Z_-]{4,36}$/`

## 实例方法

Aegis 实例暴露接口简单实用，目前 Aegis 实例有以下方法供您使用：  
`setConfig` 、 `info` 、 `infoAll` 、 `report` 、 `error` 、 `reportEvent` 、 `reportTime` 、 `time` 、 `timeEnd`

### setConfig

该方法用来修改实例配置，比如下面场景：  
在实例化 Aegis 时需要传入配置对象

```javascript
const aegis = new Aegis({
  id: 'pGUVFTCZyewxxxxx',
  uin: '777'
})
```

很多情况下，并不能一开始就获取到用户的 `uin`，而等获取到用户的 `uin` 才开始实例化 Aegis 就晚了，这期间发生的错误 Aegis 将监听不到。`uin` 的设置可以在获取到用户的时候：

```javascript
const aegis = new Aegis({
  id: 'pGUVFTCZyewxxxxx'
})

// 拿到uin之后...
aegis.setConfig({
  uin: '6666'
})
```

### info、infoAll、report、error

这三个方法是 Aegis 提供的主要上报手段。

```javascript
aegis.info('上报一条白名单日志，这两种情况这条日志才会报到后台：1、打开页面的用户在名单中；2、对应的页面发生了错误🤨');

aegis.infoAll('上报了一条日志，该上报与info唯一的不同就在于，所有用户都会上报');

aegis.error(new Error('主动上报一个错误'));
```

### reportEvent

该方法可用来上报自定义事件，平台将会自动统计上报事件的各项指标，诸如：PV、平台分布等...

reportEvent 可以支持两种类型上报参数类型，一种是字符串类型

```javascript
aegis.reportEvent('XXX请求成功');
```

一种是对象类型，ext1 ext2 ext3 默认使用 new Aegis 的时候传入的参数，自定义事件上报的时候，可以覆盖默认值。

```javascript
aegis.reportEvent({
    name: 'XXX请求成功', // 必填
    ext1: '额外参数1',
    ext2: '额外参数2',
    ext3: '额外参数3',
})
```

注意，额外参数的三个 key 是固定的，目前只支持 ext1 ext2 ext3。

### reportTime

该方法可用来上报自定义测速，例如：

```javascript
// 假如‘onload’的时间是1s
aegis.reportTime('onload', 1000);
```

或者如果需要使用额外参数，可以传入对象类型参数，ext1，ext2，ext3 会覆盖默认值：

```javascript
aegis.reportTime({
    name: 'onload', // 自定义测速名称
    duration: 1000, // 自定义测速耗时(0 - 60000)
    ext1: 'test1',
    ext2: 'test2',
    ext3: 'test3',
});
```

> `onload` 可以修改为其他的命名。

### time、timeEnd

该方法同样可用来上报自定义测速，适用于两个时间点之间时长的计算并上报，例如：

```javascript
aegis.time('complexOperation');
/**
 * .
 * .
 * 做了很久的复杂操作之后。。。
 * .
 * .
 */
aegis.timeEnd('complexOperation'); /** 此时日志已经报上去了😄**/
```

> `complexOperation` 同样可以修改为其他的命名。
> 自定义测速是用户上报任意值，服务端对其进行统计和计算，因为服务端不能做脏数据处理，因此建议用户在上报端进行统计值限制，防止脏数据对整体产生影响。
> 目前 Aegis 只支持 0-60000 的数值计算，如果大于该值，建议进行合理改造。

## 白名单

白名单功能是适用于开发者希望对某些特定的用户上报更多的日志，但是又不希望太多上报来影响到全部日志数据，并且减少用户的接口请求次数，因此 TAM 设定了白名单的逻辑。

1. 白名单用户会上报全部的 API 请求信息，包括接口请求和请求结果。
2. 白名单用户可以使用 info 接口上报数据。
3. info vs infoAll：在开发者实际体验过程中，白名单用户可以添加更多的日志，并且使用 info 进行上报。infoAll 会对所有用户无差别进行上报，因此可能导致日志量上报巨大。
4. 通过接口 whitelist 来判断当前用户是否是白名单用户，白名单用户的返回结果会绑定在 aegis 实例上 (aegis.isWhiteList) 用来给开发者使用。
5. 用了减少开发者使用负担，白名单用户是团队有效，可以在 [应用管理-白名单管理](https://console.cloud.tencent.com/rum/web/group-whitelist-manage) 内创建白名单，则团队下全部项目都生效。

## 钩子函数

### onBeforeRequest

该钩子函数会在所有请求发出前调用，参数中会传入请求的所有内容，必须返回待发送内容。

```javascript
function changeURLArg(url,arg,arg_val){ 
    var pattern=arg+'=([^&]*)'; 
    var replaceText=arg+'='+arg_val; 
    if (url.match(pattern)){ 
        var tmp='/('+ arg+'=)([^&]*)/gi'; 
        tmp=url.replace(eval(tmp),replaceText); 
        return tmp;  
    }
    return url
}
const aegis = new Aegis({
    id: 'pGUVFTCZyewxxxxx',
    onBeforeRequest(log) {
        if (log.type === 'performance') {
            // 页面测速，此时可以修改log内容，如修改页面测速platform
            log.url = changeURLArg(log.url, 'platform', type)
        }
        return log
    }
});

//  SendType {
//     LOG = 'log',  // 日志
//     SPEED = 'speed', // 接口和静态资源测速
//     PERFORMANCE = 'performance', // 页面测速
//     OFFLINE = 'offline', // 离线日志上传
//     WHITE_LIST = 'whiteList', // 白名单
//     VITALS = 'vitals', // vitals
//     PV = 'pv', // 自定义pv
//     EVENT = 'event', // 自定义事件
//     CUSTOM = 'custom', // 自定义测速
//     SDK_ERROR = 'sdkError', // sdk报错
// }
```

### beforeReport

该钩子将会在日志上报（对应上报接口为 /collect?）前执行，例如：

```javascript
const aegis = new Aegis({
    id: 'pGUVFTCZyewxxxxx',
    beforeReport(log) {
        // 监听到下面抛出的错误
        console.log(log); // {level: "4", msg: "发生错误啦！！！！"}
        return log;
    }
});

throw new Error('发生错误啦！！！！');
```

其中，`log` 将会有以下几个字段：  

> 1.`level`: 日志等级，例如：当 level 为 '4' 时代表错误日志；  

> 2.`msg`: 日志内容；

全部日志等级如下

```sh
{ level: '1', name: '接口请求日志（白名单日志）' },
{ level: '2', name: '一般日志' },
{ level: '4', name: 'JS 执行错误' },
{ level: '8', name: 'Promise 错误' },
{ level: '16', name: 'Ajax 请求异常' },
{ level: '32', name: 'JS 加载异常' },
{ level: '64', name: '图片加载异常' },
{ level: '128', name: 'css 加载异常' },
{ level: '256', name: 'console.error (未启用)' },
{ level: '512', name: '音视频资源异常' },
{ level: '1024', name: 'retcode 异常' },
{ level: '2048', name: 'aegis report' }
```

当该钩子返回 `false` 时，本条日志将不会进行上报，该功能可用来过滤某些不需要上报的错误，例如：

```javascript
const aegis = new Aegis({
    id: 'pGUVFTCZyewxxxxx',
    beforeReport(log) {
        if (log.level === '4' && log.msg && log.msg.indexOf('碍眼的错误') !== -1) {
            return false
        }
        return log;
    }
});
throw new Error('碍眼的错误'); // 该错误将不会被上报
```

上面例子中，当上报的错误内容包含 `碍眼的错误` 几个关键字时，将不会上报至 Aegis 后台中。

### onReport

该钩子将在日志上报成功之后执行，用法类似 `beforeReport` 钩子，唯一不同点在于，该钩子接收到的所有参数都是已经上报完成的日志，而 `beforeReport` 钩子接收的参数是即将上报的日志。

### beforeReportSpeed

该勾子将会在测速数据上报前（/speed?）被执行，例如：

```javascript
const aegis = new Aegis({
    id: 'pGUVFTCZyewxxxxx',
    reportApiSpeed: true,
    reportAssetSpeed: true,
    beforeReportSpeed(msg) {
        console.log(msg); // {url: "https://localhost:3001/example.e31bb0bc.js", method: "get", duration: 7.4, status: 200, type: "static"}
        return msg
    }
});
```

其中，`msg` 将会有以下几个字段：  

> 1.`url`: 该资源的请求地址；  

> 2.`type`: 该资源的类型，目前有 `fetch` 、 `static` 两种，当为 `fetch` 时，Aegis 将会把该资源当成 API 请求进行上报，`static` 时则视为静态资源；  

> 3.`duration`: 该资源请求耗时；  

> 4.`method`: 请求该资源时使用的 `http method`；  

> 5.`status`: 服务器返回状态码；  

> 6.`payload`: 提供给开发人员的完整资源请求信息（此数据不上报到aegis后台，用户可自行操作）  
> 完整的数据结构如下：  
> `payload.type` - 表示该资源请求的类型，用于区分原始请求类型，可取值为：`'fetch'`, `'xhr'`  
> `payload.sourceURL` - 表示完整的url请求连接  
> `payload.status` - 表示请求状态码  
> `payload.headers` - 包含所有的请求头，且value值都为字符串  
> `payload.data` - 表示完整的请求资源，用户可自定义操作（当请求类型为fetch时，表示response对象；当请求类型为xhr时，表示XMLHttpRequest对象）  

上面的 🌰中，每当 Aegis 收集到一个资源的加载详情时，将会以该资源的加载情况（上面的`msg`）作为参数调用 `beforeReportSpeed` 勾子。  

如果您配置了该勾子，**Aegis 最终的上报内容将以勾子的执行结果为准**。例如：

```javascript
const aegis = new Aegis({
    id: 'pGUVFTCZyewxxxxx',
    reportApiSpeed: true,
    reportAssetSpeed: true,
    beforeReportSpeed(msg) {
        msg.type = 'static';
        return msg;
    }
});
```

上面的代码中，将所有的 `msg.type` 设置为 `static`，这意味着所有的资源都将被当成静态资源进行上报，API 请求也将被报至静态资源中。  

使用该勾子，您可以校准 Aegis 类型判断错误的请求。  
比方说，假如您有一条接口 `https://example.com/api`，该接口的响应头 `Content-Type` 为 `text/html`，
正常情况下，Aegis 会将该资源当成静态资源进行上报。但在您的业务中，该接口就必须视为 API 请求进行上报，您可以给 Aegis 配置如下勾子进行校正：

```javascript
const aegis = new Aegis({
    id: 'pGUVFTCZyewxxxxx',
    reportApiSpeed: true,
    reportAssetSpeed: true,
    beforeReportSpeed(msg) {
        if (msg.url === 'https://example.com/api') {
            msg.type = 'fetch';
        }
    }
});
```

您还可以屏蔽某些资源的测速上报，例如：

```javascript
const aegis = new Aegis({
    id: 'pGUVFTCZyewxxxxx',
    reportApiSpeed: true,
    reportAssetSpeed: true,
    beforeReportSpeed(msg) {
        // 地址中包含‘https://example.com/api’的都不上报
        if (msg.url.indexOf('https://example.com/api') !== -1) {
            // 返回 ‘false’ 将阻止本条测速日志的上报
            return false
        }
    }
});
```

## 错误监控

::: warning
Aegis 的实例会自动进行以下监控，注意！是 Aegis 实例会进行监控，当您只是引入了 SDK 而没有将其实例化时，Aegis 将什么都不会做。
:::

### JS执行错误

Aegis 通过监听 `window` 对象上的 `onerror` 事件来获取项目中的报错，并且通过解析错误和分析堆栈，将错误信息自动上报到后台服务中。该上报的上报等级为 error ，所以，当自动上报的错误达到阈值时，Aegis 将会自动告警，帮助您尽早发现异常。由于上报等级为 error ，自动上报也将影响项目的评分。
> 如果页面上引入了跨域的JS脚本，需要给对应的 `script` 标签添加 `crossorigin` 属性，否则 Aegis 将无法获取详细的错误信息。

注意如果用户使用的是 vue 框架，请务必自己获取错误并且主动上报

```javascript
Vue.config.errorHandler = function(err, vm, info) {
    console.log(`Error: ${err.toString()}\nInfo: ${info}`);
    aegis.error(`Error: ${err.toString()}\nInfo: ${info}`);
};
```

#### Script error

Script error. 也被称为跨域错误，当网站请求并且执行一个非本域名下的脚步的时候，如果跨域脚本发生错误，就有可能抛出这个错误。由于项目中，我们的脚本都是放在 CDN 上的，因此这种错误最为常见。

其实这并不是一个JavaScript Bug。出于安全考虑，浏览器会刻意隐藏其他域的JS文件抛出的具体错误信息，这样做可以有效避免敏感信息无意中被不受控制的第三方脚本捕获。因此，浏览器只允许同域下的脚本捕获具体错误信息，而其他脚本只知道发生了一个错误，但无法获知错误的具体内容。更多信息，请参见 [Webkit源码](https://trac.webkit.org/browser/branches/chromium/648/Source/WebCore/dom/ScriptExecutionContext.cpp?spm=a2c63.p38356.879954.4.35155db7eUvHNi&file=ScriptExecutionContext.cpp#L294)。



### Promise执行错误

通过监听 `unhandledrejection` 事件，捕获到未被 `catch` 的Promise错误，为了页面的健壮，建议您 `catch` 住所有的Promise错误哟。

### Ajax（Fetch）请求异常

Aegis 将会改写 `XMLHttpRequest` 对象，监听每次接口请求，Aegis 认为以下情况是异常情况：  
1. `http status` 大于 400
2. 请求超时
3. 请求结束时 `http status` 仍然是 0，通常发生于请求失败

### 返回码异常

同上，Aegis 改写 `XMLHttpRequest` 对象之后，将获得API返回的内容，并尝试在内容中获取到本次请求的 `retcode`，
当 `retcode` 不符合预期的时候，会认为本次请求出现了异常，并进行上报。
> 如何获取 `retcode` 以及哪些`retcode` 是正常的可以在配置文档中查看。

### 资源加载失败

页面元素发出的请求如果失败，将会被 `window.onerror` 事件捕获到（捕获阶段），Aegis 正是通过这个特性监听的资源加载失败。Aegis监听了以下资源：  

1. `<link>` 标签请求的css、font等；
2. `<script>` 标签请求的脚本；
3. `<audio>`、`<video>` 标签请求的多媒体资源；

## 性能监控

### 页面测速

> 打开方式：默认开启  

Aegis 实例默认会上报以下指标：  

**1. DNS查询**：domainLookupEnd - domainLookupStart；  
**2. TCP连接**：connectEnd - connectStart；  
**3. SSL建连**：requestStart - secureConnectionStart；  
**4. 请求响应**：responseStart - requestStart；  
**5. 内容传输**：responseEnd - responseStart；  
**6. DOM解析**：domInteractive - domLoading；  
**7. 资源加载**：loadEventStart - domInteractive；  
**8. 首屏耗时**：监听页面打开3s内的 **首屏** DOM 变化，并认为 DOM 变化数量最多的那一刻为首屏框架渲染完成时间（sdk初始化后setTimeout 3s收集首屏元素，由于js是在单线程环境下执行，收集时间点可能大于3s）；  
**9. 页面完加载时间**： 为前面7项数据之和；  

> 前7项计算材料从 [PerformanceTiming](https://developer.mozilla.org/en-US/docs/Web/API/Performance/timing) 获取。首屏耗时对应的 dom 元素，可以通过打印 aegis.firstScreenInfo 查看。如果 dom 元素不能代表首屏，可以添加属性 \<div `AEGIS-FIRST-SCREEN-TIMING`\>\<\/div\>，把某个元素识别为首屏关键元素，SDK 认为只要用户首屏出现此元素就是首屏完成。也可以添加属性 \<div `AEGIS-IGNORE-FIRST-SCREEN-TIMING`\>\<\/div\>，把该 dom 列入黑名单。

根据以上数据，TAM 为用户绘制了页面加载瀑布图

![页面加载瀑布图](https://nowpic.gtimg.com/feeds_pic/kZXyd7Yh5phaicL6rEVF6T6WqpmEnWrABkff3anQHeGs/)

> 在服务端直出场景，瀑布图会出现首屏时间大于dom解析的情况，这是由于移动端设备兼容性问题，有些设备无法获取到DNS查询、TCP连接、SSL建连时间，这三个指标汇总后的平均值偏小，导致除了首屏时间外的其他指标都往左偏移。

### 接口测速

> 打开方式：初始化时传入配置 `reportApiSpeed: true`  

Aegis 通过劫持 `XHR` 及 `fetch` 进行接口测速，具体代码在 [这里](https://git.code.oa.com/tam/aegis-sdk/blob/master/packages/web-sdk/src/plugins/cgi-speed.ts)

### 资源测速

> 打开方式：初始化时传入配置 `reportAssetSpeed: true`  

Aegis 通过浏览器提供的 `PerformanceResourceTiming` 进行资源测速，具体代码在 [这里](https://git.code.oa.com/tam/aegis-sdk/blob/master/packages/web-sdk/src/plugins/asset-speed.ts)

## 离线日志

Aegis SDK 使用 flog(https://cdn-go.cn/vasdev/web_webpersistance_v2/latest/flog.core.min.js) 管理收集和上报离线日志，用户只需要简单配置就可以使用

1. 在 SDK 中开启离线日志参数

```javascript
new Aegis({
  offlineLog: true, // 开启离线日志
})
```

离线日志开启后，用户的日志就会被收集到浏览器的 IndexedDB 中，但是并不会实时上报，需要开发者对用户 uin 进行监听

2. 打开开发者平台对该用户进行监听

![监听用户](https://nowpic.gtimg.com/feeds_pic/PiajxSqBRaEJRHgqJawVuiaABmYJaPEE4DnLUicjRzSPHlyAnv8IpaTnw/)

3. 当用户下次打开页面或者代码中执行 setConfig 的时候，用户将日志上报到 TAM 服务端

这个时候，用户侧会发两个接口，一个是 `aegis.qq.com/collect/offlineAuto`，用来判断是否要发送离线日志，并且返回加密 token
一个是 `aegis.qq.com/collect/offlineLog`，用来上报当前用户 indexedDB 中存放的离线日志

4. 查看日志

![查看离线日志](https://nowpic.gtimg.com/feeds_pic/PiajxSqBRaELPvEiawiaQdBfibvib9icdqkQaovltMyHaWN9q2FH8NEPGAtw/)

## 配置文档

| 配置 | 描述 |
| -------- | -------- |
| id | 必须，string，默认 无。<br>开发者平台分配的项目ID |
| uin | 建议，string，默认取 cookie 中的 uin 字段。<br>当前用户的唯一标识符，白名单上报时将根据该字段判定用户是否在白名单中，字段仅支持`字母数字@=._-`，正则表达式: `/^[@=.0-9a-zA-Z_-]{1,60}$/` |
| reportApiSpeed | 可选，boolean 或者 <span id="jump">[object](#exp2)</span>，默认 false。<br>是否开启接口测速 |
| reportAssetSpeed | 可选，boolean，默认 false。<br>是否开启静态资源测速 |
| pagePerformance | 可选，boolean 或者 <span id="jump">[object](#exp3)</span>，默认 true。<br>是否开启页面测速 |
| webVitals | 可选，boolean，默认 true。<br>是否开启 web vitals 测速 |
| onError | 可选，boolean，默认 true。<br>当前实例是否需要进行错误监听，获取错误日志 |
| aid | 可选，boolean，默认 true。<br>当前实例是否生成aid |
| random | 可选，number，默认 1。<br>0~1 抽样率 |
| spa | 可选，boolean，默认 false。 <br> 当前页面是否是单页应用？true的话将会监听hashchange及history api，在页面跳转时进行pv上报 |
| version | 可选，string，默认 sdk 版本号。<br>当前上报版本，当页面使用了pwa或者存在离线包时，可用来判断当前的上报是来自哪一个版本的代码，仅支持`字母数字.,:_-`，长度在 60 位以内 `/^[0-9a-zA-Z.,:_-]{1,60}$/` |
| delay | 可选，number，默认 1000 ms。<br>上报节流时间，在该时间段内的上报将会合并到一个上报请求中。 |
| websocketHack | 可选，boolean，默认 false <br>是否开启websocket监控。 |
| repeat | 可选，number，默认 5。<br>重复上报次数，对于同一个错误超过多少次不上报。 |
| offlineLog | 可选，boolean，默认 false。<br>是否使用离线日志 |
| offlineLogExp | 可选，number，默认 3。<br>离线日志过期天数 |
| api | 可选，object，默认为{}。相关的配置: <br> apiDetail : 可选，boolean，默认false。api 失败的时候，是否上报 api 的请求参数和返回值;<br> retCodeHandler: Function(data: String, url: String, xhr: Object):{isErr: boolean, code: string}， 返回码上报钩子函数。 会传入接口返回数据,请求url和xhr对象<br> resourceTypeHandler: Function，请求资源类型修正钩子函数 会传入接口url，返回值为‘static’或‘fetch’。<span id="jump">[见示例[1]](#exp1)</span>|
| speedSample | 可选，boolean，默认 true。<br>测速日志是否抽样（限制每条url只上报一次测速日志） |
| hostUrl | 可选，默认是 `aegis.qq.com`。<br>影响全部上报数据的 host 地址，下面几个 url 地址设置后会覆盖对应的上报地址 ｜
| url | 可选，string，默认 '//aegis.qq.com/collect'。<br>日志上报地址|
| pvUrl | 可选，string，默认 '//aegis.qq.com/collect/pv'。<br>pv上报地址|
| speedUrl | 可选，string，默认 '//aegis.qq.com/speed'。<br>测速日志上报地址 |
| performanceUrl | 可选，string，默认 '//aegis.qq.com/speed/performance'。<br>页面性能日志上报地址 |
| webVitalsUrl | 可选，string，默认 '//aegis.qq.com/speed/webvitals'。<br>页面 web vitals 日志上报地址 |
| whiteListUrl | 可选，string，默认 '//aegis.qq.com/collect/whitelist'。<br>白名单确认接口 <br>如果想要关闭白名单接口请求，可以传空字符串|
| dbConfig | 可选，Object，参考地址：https://git.code.oa.com/vasdev/web_webpersistance_v2 （配置 params）|
| ext1 | 可选，string，自定义上报的额外维度，上报的时候可以被覆盖 |
| ext2 | 可选，string，自定义上报的额外维度，上报的时候可以被覆盖 |
| ext3 | 可选，string，自定义上报的额外维度，上报的时候可以被覆盖 |

### 示例

**[1] api.retCodeHandler**<span id="exp1"></span>，假如后台返回数据为:
```json
{
    body: {
        code: 200,
        retCode: 0,
        data: {
            // xxx
        }
    }
}

```

业务需要：code不为200，或者retCode不为0，此次请求就是错误的。此时只需进行以下配置：

```javascript
new Aegis({
  reportApiSpeed: true, // 需要开两个，不然不会有返回码上报
  reportAssetSpeed: true,
  api: {
    retCodeHandler(data, url, xhr) {
      // data 是string类型，如果需要对象需要手动parse下
      // url 为请求url
      // xhr 响应,可以通过xhr.response拿到完整的后台响应
      try {
        data = JSON.parse(data)
      } catch(e) {}
      return {
        isErr: data.body.code !== 200 || data.body.retCode !== 0,
        code:  data.body.code
      }
    }
  }
})
```

**api.resourceTypeHandler**，假如接口  

`http://example.com/test-api`  

返回的 `Content-Type` 为 `text/html`，这将导致 Aegis 认为该接口返回的是静态资源，可以通过以下方法修正：

```javascript
new Aegis({
  reportApiSpeed: true, // 需要开两个，不然不会有返回码上报
  reportAssetSpeed: true,
  api: {
    resourceTypeHandler(url) {
      if (url?.indexOf('http://example.com/test-api') != -1) {
        return 'fetch';
      }
    }
  }
})
```

**[2] reportApiSpeed.urlHandler**<span id="exp2"></span>，假如您页面中有restful风格的接口，如：  
*www.example.com/user/1000*  
*www.example.com/user/1001*

在上报测速时需要将这些接口聚合：

```javascript
new Aegis({
  reportApiSpeed: {
    urlHandler(url, payload) {
      if ((/www\.example\.com\/user\/\d*/).test(url)) {
        return 'www.example.com/user/:id';
      }
      return url;
    }
  }
})
```

**[3] pagePerformance.urlHandler**<span id="exp3"></span>，假如您的页面url是restful风格的，如：  
*www.example.com/user/1000*  
*www.example.com/user/1001*

在上报页面测速时需要将这些页面地址聚合：

```javascript
new Aegis({
    // xxx
  pagePerformance: {
    urlHandler() {
      if ((/www\.example\.com\/user\/\d*/).test(window.location.href)) {
        return 'www.example.com/user/:id';
      }
    }
  }
})
```
